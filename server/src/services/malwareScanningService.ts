import { EventEmitter } from 'events';
import { PrismaClient } from '@prisma/client';
import { logger } from '../lib/logger';
import {
  MalwareScanResult,
  VulnerabilityCheckResult,
  SecurityScanReport
} from '../../../shared/dist/types/security';

/**
 * Malware Scanning Service
 * Handles real-time malware scanning and vulnerability detection
 * Following our Service Architecture Standards
 */
export class MalwareScanningService extends EventEmitter {
  private prisma: PrismaClient;
  private readonly CACHE_DURATION = 15 * 60 * 1000; // 15 minutes
  private readonly VIRUSTOTAL_API_KEY = process.env.VIRUSTOTAL_API_KEY;
  private readonly VIRUSTOTAL_API_URL = 'https://www.virustotal.com/vtapi/v2';

  constructor(prisma: PrismaClient) {
    super();
    this.prisma = prisma;
  }

  /**
   * Scan module for malware using VirusTotal API
   * @param moduleData - Module submission data
   * @returns Malware scan result
   */
  async scanModuleForMalware(moduleData: Record<string, unknown>): Promise<MalwareScanResult> {
    try {
      console.log('üîç Starting malware scan for module...');
      
      const manifest = moduleData.manifest as Record<string, unknown>;
      const frontend = manifest?.frontend as Record<string, unknown>;
      const entryUrl = frontend?.entryUrl as string;
      
      if (!entryUrl) {
        throw new Error('Module URL not found for malware scanning');
      }

      // Check if we have VirusTotal API key
      if (!this.VIRUSTOTAL_API_KEY) {
        console.warn('‚ö†Ô∏è VirusTotal API key not configured, using basic scan');
        return await this.performBasicMalwareScan(moduleData);
      }

      // Scan URL with VirusTotal
      const urlScanResult = await this.scanUrlWithVirusTotal(entryUrl);
      
      // Scan module content if available
      const contentScanResult = await this.scanModuleContent(moduleData);
      
      // Combine results
      const combinedResult: MalwareScanResult = {
        isClean: urlScanResult.isClean && contentScanResult.isClean,
        scanId: `scan_${Date.now()}`,
        scanDate: new Date().toISOString(),
        detectedThreats: [
          ...urlScanResult.detectedThreats,
          ...contentScanResult.detectedThreats
        ],
        scanProvider: 'virustotal',
        confidence: Math.min(urlScanResult.confidence, contentScanResult.confidence),
        details: {
          urlScan: urlScanResult,
          contentScan: contentScanResult,
          scanDuration: Date.now() - parseInt(urlScanResult.scanId.split('_')[1])
        }
      };

      this.emit('malwareScanComplete', { moduleData, result: combinedResult });
      
      await logger.info('Malware scan completed', {
        operation: 'malware_scanning',
        moduleId: moduleData.id,
        isClean: combinedResult.isClean,
        threatsDetected: combinedResult.detectedThreats.length
      });

      console.log(`‚úÖ Malware scan completed. Clean: ${combinedResult.isClean}`);
      return combinedResult;

    } catch (error) {
      console.error('‚ùå Error in malware scanning:', error);
      await logger.error('Malware scanning failed', {
        operation: 'malware_scanning',
        moduleId: moduleData.id,
        error: {
          message: error instanceof Error ? error.message : 'Unknown error',
          stack: error instanceof Error ? error.stack : undefined
        }
      });
      throw error;
    }
  }

  /**
   * Check module for vulnerabilities
   * @param moduleData - Module submission data
   * @returns Vulnerability check result
   */
  async checkModuleVulnerabilities(moduleData: Record<string, unknown>): Promise<VulnerabilityCheckResult> {
    try {
      console.log('üîç Checking module for vulnerabilities...');
      
      const manifest = moduleData.manifest as Record<string, unknown>;
      const dependencies = manifest?.dependencies as string[] || [];
      
      const vulnerabilities: VulnerabilityCheckResult['vulnerabilities'] = [];

      // Check each dependency for vulnerabilities
      for (const dependency of dependencies) {
        const depVulnerabilities = await this.checkDependencyVulnerabilities(dependency);
        vulnerabilities.push(...depVulnerabilities);
      }

      // Check for known vulnerable patterns in manifest
      const manifestVulnerabilities = await this.checkManifestVulnerabilities(manifest);
      vulnerabilities.push(...manifestVulnerabilities);

      const result: VulnerabilityCheckResult = {
        hasVulnerabilities: vulnerabilities.length > 0,
        vulnerabilities,
        scanDate: new Date().toISOString(),
        summary: {
          totalVulnerabilities: vulnerabilities.length,
        criticalVulnerabilities: vulnerabilities.filter((v: any) => v.severity === 'critical').length,
        highVulnerabilities: vulnerabilities.filter((v: any) => v.severity === 'high').length,
        mediumVulnerabilities: vulnerabilities.filter((v: any) => v.severity === 'medium').length,
        lowVulnerabilities: vulnerabilities.filter((v: any) => v.severity === 'low').length
        }
      };

      this.emit('vulnerabilityCheckComplete', { moduleData, result });
      
      await logger.info('Vulnerability check completed', {
        operation: 'vulnerability_checking',
        moduleId: moduleData.id,
        vulnerabilitiesFound: vulnerabilities.length,
        criticalVulnerabilities: result.summary.criticalVulnerabilities
      });

      console.log(`‚úÖ Vulnerability check completed. Found: ${vulnerabilities.length} vulnerabilities`);
      return result;

    } catch (error) {
      console.error('‚ùå Error in vulnerability checking:', error);
      await logger.error('Vulnerability checking failed', {
        operation: 'vulnerability_checking',
        moduleId: moduleData.id,
        error: {
          message: error instanceof Error ? error.message : 'Unknown error',
          stack: error instanceof Error ? error.stack : undefined
        }
      });
      throw error;
    }
  }

  /**
   * Scan URL with VirusTotal API
   */
  private async scanUrlWithVirusTotal(url: string): Promise<MalwareScanResult> {
    try {
      const formData = new FormData();
      formData.append('apikey', this.VIRUSTOTAL_API_KEY!);
      formData.append('url', url);

      const response = await fetch(`${this.VIRUSTOTAL_API_URL}/url/scan`, {
        method: 'POST',
        body: formData
      });

      if (!response.ok) {
        throw new Error(`VirusTotal API error: ${response.status}`);
      }

      const scanResponse = await response.json() as any;
      
      // Wait for scan to complete and get results
      await new Promise(resolve => setTimeout(resolve, 30000)); // Wait 30 seconds
      
      const reportResponse = await fetch(`${this.VIRUSTOTAL_API_URL}/url/report?apikey=${this.VIRUSTOTAL_API_KEY}&resource=${scanResponse.scan_id}`);
      const report = await reportResponse.json() as any;

      const detectedThreats: string[] = [];
      let confidence = 100;

      if (report.scans) {
        for (const [engine, result] of Object.entries(report.scans)) {
          const scanResult = result as any;
          if (scanResult.detected) {
            detectedThreats.push(`${engine}: ${scanResult.result}`);
            confidence -= 10; // Reduce confidence for each detection
          }
        }
      }

      return {
        isClean: detectedThreats.length === 0,
        scanId: scanResponse.scan_id,
        scanDate: new Date().toISOString(),
        detectedThreats,
        scanProvider: 'virustotal',
        confidence: Math.max(confidence, 0)
      };

    } catch (error) {
      console.error('VirusTotal scan failed:', error);
      // Fallback to basic scan
      return await this.performBasicMalwareScan({ manifest: { frontend: { entryUrl: url } } });
    }
  }

  /**
   * Scan module content for malware patterns
   */
  private async scanModuleContent(moduleData: Record<string, unknown>): Promise<MalwareScanResult> {
    const suspiciousPatterns = [
      /eval\s*\(/i,
      /document\.write/i,
      /innerHTML\s*=/i,
      /outerHTML\s*=/i,
      /window\.location/i,
      /document\.cookie/i,
      /XMLHttpRequest/i,
      /fetch\s*\(/i,
      /atob\s*\(/i,
      /btoa\s*\(/i
    ];

    const detectedThreats: string[] = [];
    let confidence = 100;

    // Check manifest for suspicious patterns
    const manifest = moduleData.manifest as Record<string, unknown>;
    const manifestStr = JSON.stringify(manifest);
    
    for (const pattern of suspiciousPatterns) {
      if (pattern.test(manifestStr)) {
        detectedThreats.push(`Suspicious pattern in manifest: ${pattern.source}`);
        confidence -= 15;
      }
    }

    // Check description for suspicious content
    const description = moduleData.description as string || '';
    const suspiciousKeywords = ['malware', 'virus', 'trojan', 'backdoor', 'keylogger', 'spyware'];
    
    for (const keyword of suspiciousKeywords) {
      if (description.toLowerCase().includes(keyword)) {
        detectedThreats.push(`Suspicious keyword in description: ${keyword}`);
        confidence -= 20;
      }
    }

    return {
      isClean: detectedThreats.length === 0,
      scanId: `content_scan_${Date.now()}`,
      scanDate: new Date().toISOString(),
      detectedThreats,
      scanProvider: 'content-scanner',
      confidence: Math.max(confidence, 0)
    };
  }

  /**
   * Perform basic malware scan (fallback method)
   */
  private async performBasicMalwareScan(moduleData: Record<string, unknown>): Promise<MalwareScanResult> {
    const manifest = moduleData.manifest as Record<string, unknown>;
    const frontend = manifest?.frontend as Record<string, unknown>;
    const entryUrl = frontend?.entryUrl as string;
    
    // Basic URL checks
    const suspiciousDomains = [
      'malware.com',
      'virus.com',
      'trojan.com',
      'backdoor.com',
      'keylogger.com'
    ];

    const detectedThreats: string[] = [];
    let confidence = 95;

    if (entryUrl) {
      for (const domain of suspiciousDomains) {
        if (entryUrl.toLowerCase().includes(domain)) {
          detectedThreats.push(`Suspicious domain detected: ${domain}`);
          confidence -= 30;
        }
      }
    }

    return {
      isClean: detectedThreats.length === 0,
      scanId: `basic_scan_${Date.now()}`,
      scanDate: new Date().toISOString(),
      detectedThreats,
      scanProvider: 'basic-scanner',
      confidence
    };
  }

  /**
   * Check dependency for vulnerabilities
   */
  private async checkDependencyVulnerabilities(dependency: string): Promise<VulnerabilityCheckResult['vulnerabilities']> {
    const vulnerabilities: VulnerabilityCheckResult['vulnerabilities'] = [];

    // Known vulnerable packages (in a real implementation, this would query npm audit or similar)
    const knownVulnerablePackages = {
      'lodash': [
        {
          id: 'CVE-2019-10744',
          severity: 'medium' as const,
          description: 'Prototype pollution vulnerability',
          cve: 'CVE-2019-10744',
          affectedDependencies: ['lodash']
        }
      ],
      'axios': [
        {
          id: 'CVE-2021-3749',
          severity: 'high' as const,
          description: 'Server-Side Request Forgery (SSRF) vulnerability',
          cve: 'CVE-2021-3749',
          affectedDependencies: ['axios']
        }
      ]
    };

    const packageName = dependency.split('@')[0];
    const packageVulnerabilities = knownVulnerablePackages[packageName as keyof typeof knownVulnerablePackages];
    
    if (packageVulnerabilities) {
      vulnerabilities.push(...packageVulnerabilities);
    }

    return vulnerabilities;
  }

  /**
   * Check manifest for vulnerability patterns
   */
  private async checkManifestVulnerabilities(manifest: Record<string, unknown>): Promise<VulnerabilityCheckResult['vulnerabilities']> {
    const vulnerabilities: VulnerabilityCheckResult['vulnerabilities'] = [];

    // Check for dangerous permissions
    const permissions = manifest.permissions as string[] || [];
    const dangerousPermissions = [
      'file-system',
      'network-access',
      'process-spawn',
      'system-access'
    ];

    for (const permission of permissions) {
      if (dangerousPermissions.some(dangerous => permission.includes(dangerous))) {
        vulnerabilities.push({
          id: `permission_${permission}`,
          severity: 'medium' as const,
          description: `Dangerous permission requested: ${permission}`,
          affectedDependencies: [permission]
        });
      }
    }

    // Check for outdated API versions
    const runtime = manifest.runtime as Record<string, unknown>;
    const apiVersion = runtime?.apiVersion as string;
    
    if (apiVersion && apiVersion < '1.0') {
      vulnerabilities.push({
        id: 'outdated_api_version',
        severity: 'low' as const,
        description: `Outdated API version: ${apiVersion}`,
        affectedDependencies: ['runtime.apiVersion']
      });
    }

    return vulnerabilities;
  }

  /**
   * Generate comprehensive security scan report
   */
  async generateSecurityScanReport(moduleData: Record<string, unknown>): Promise<SecurityScanReport> {
    try {
      console.log('üìä Generating comprehensive security scan report...');

      const malwareScan = await this.scanModuleForMalware(moduleData);
      const vulnerabilityCheck = await this.checkModuleVulnerabilities(moduleData);

      const report: SecurityScanReport = {
        moduleId: moduleData.id as string || 'unknown',
        moduleName: moduleData.name as string || 'Unknown Module',
        scanDate: new Date().toISOString(),
        overallStatus: malwareScan.isClean && !vulnerabilityCheck.hasVulnerabilities ? 'passed' : 'failed',
        securityScore: this.calculateSecurityScore(malwareScan, vulnerabilityCheck),
        malwareScan,
        vulnerabilityCheck,
        recommendations: this.generateRecommendations(malwareScan, vulnerabilityCheck),
        nextSteps: this.generateNextSteps(malwareScan, vulnerabilityCheck)
      };

      this.emit('securityScanReportGenerated', { moduleData, report });
      
      await logger.info('Security scan report generated', {
        operation: 'security_scan_report',
        moduleId: moduleData.id,
        overallStatus: report.overallStatus,
        securityScore: report.securityScore
      });

      console.log(`‚úÖ Security scan report generated. Status: ${report.overallStatus}`);
      return report;

    } catch (error) {
      console.error('‚ùå Error generating security scan report:', error);
      throw error;
    }
  }

  /**
   * Calculate overall security score
   */
  private calculateSecurityScore(malwareScan: MalwareScanResult, vulnerabilityCheck: VulnerabilityCheckResult): number {
    let score = 100;

    // Deduct points for malware detections
    score -= malwareScan.detectedThreats.length * 20;

    // Deduct points for vulnerabilities
    for (const vuln of vulnerabilityCheck.vulnerabilities) {
      switch (vuln.severity) {
        case 'critical':
          score -= 25;
          break;
        case 'high':
          score -= 15;
          break;
        case 'medium':
          score -= 10;
          break;
        case 'low':
          score -= 5;
          break;
      }
    }

    return Math.max(score, 0);
  }

  /**
   * Generate security recommendations
   */
  private generateRecommendations(malwareScan: MalwareScanResult, vulnerabilityCheck: VulnerabilityCheckResult): string[] {
    const recommendations: string[] = [];

    if (!malwareScan.isClean) {
      recommendations.push('Address detected malware threats before approval');
    }

    if (vulnerabilityCheck.hasVulnerabilities) {
      recommendations.push('Update vulnerable dependencies to latest versions');
      recommendations.push('Review and minimize module permissions');
    }

    if (malwareScan.confidence < 80) {
      recommendations.push('Consider additional security review due to low confidence score');
    }

    return recommendations;
  }

  /**
   * Generate next steps for module approval
   */
  private generateNextSteps(malwareScan: MalwareScanResult, vulnerabilityCheck: VulnerabilityCheckResult): string[] {
    const nextSteps: string[] = [];

    if (malwareScan.isClean && !vulnerabilityCheck.hasVulnerabilities) {
      nextSteps.push('Module is ready for manual review');
      nextSteps.push('Schedule sandbox testing');
    } else {
      nextSteps.push('Address security issues before proceeding');
      nextSteps.push('Request developer to fix identified problems');
    }

    return nextSteps;
  }
}
