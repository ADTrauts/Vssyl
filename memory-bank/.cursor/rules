# Project Intelligence (.cursor/rules)

## Monorepo & TypeScript Patterns
- Always use TypeScript project references for shared code (`shared` as composite, referenced by `web` and `server`).
- Build order: `shared` → `web`/`server` (enforced in root build script).
- All code must be ESLint clean (`--max-warnings=0`).
- Use clean import paths via path aliases (e.g., `import { Button } from 'shared/src/components'`).
- Use `/app` directory in Next.js, not `/pages` (legacy pages are removed).
- All configs (TypeScript, ESLint) should be unified and extended from the root where possible.
- Document all new patterns and workflows in the memory bank as they are adopted.

## Calendar Module - COMPLETED ✅
**Status**: Phase 2f fully implemented and production-ready (January 2025)

### **Key Implementation Patterns**
- **Module-Driven Provisioning**: Calendars only create when Calendar module is installed on dashboard
- **Tab-Bound Architecture**: Personal/Business/Household calendars with context-aware permissions
- **Advanced Month View**: Overlap stacking, continuation chevrons, drag-to-resize interactions
- **Real-Time Collaboration**: Socket.io integration for live calendar updates
- **Recurrence Handling**: RRULE support with child event exceptions via parentEventId

### **Technical Achievements**
- All TypeScript errors resolved in calendar controller
- Enhanced month view with professional calendar UX
- Complete ICS import/export with VTIMEZONE support
- RSVP token system with secure public access
- Advanced filtering and search with persistence
- Conflict detection and free-busy checking

### **Architecture Principles**
- **Tabs only have data/resources for modules that are installed** - This is now a core rule
- Calendar provisioning requires active calendar widget on dashboard
- Context-aware permissions (household child protections, business role mapping)
- Real-time updates via dedicated socket channels

## Project Patterns

- Always use `npx` when running CLI tools (e.g., Playwright, Prisma) to ensure the correct version and dependency resolution. This avoids issues with direct invocation and is now the standard for scripts and manual commands.

## AI Coding Standards & Best Practices
- **ALWAYS follow the comprehensive coding standards** defined in `memory-bank/AI_CODING_STANDARDS.md`
- **NEVER use `any` types** - replace with proper TypeScript types or `Record<string, unknown>`
- **Maintain consistent patterns** for AI services, routes, and API responses
- **Follow established architecture** for service classes, error handling, and database operations
- **Use proper type assertions** with `unknown` first: `(data as unknown as Type)`
- **Implement consistent error handling** with try-catch blocks and proper logging
- **Follow the established service class pattern** extending EventEmitter with PrismaClient injection 